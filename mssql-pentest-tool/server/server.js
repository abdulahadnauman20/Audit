// app.js - Main server file
const sql = require('mssql');
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const winston = require('winston');
const jwt = require('jsonwebtoken');
const rateLimit = require('express-rate-limit');
const path = require('path');
const fs = require('fs');
const bcrypt = require('bcrypt');

const app = express();
const PORT = process.env.PORT || 5000;

// Create reports directory if it doesn't exist
const reportDir = path.join(__dirname, 'reports');
if (!fs.existsSync(reportDir)) {
  fs.mkdirSync(reportDir, { recursive: true });
}

// Logger configuration
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple(),
  }));
}

// MSSQL Configuration
const dbConfig = {
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  server: process.env.DB_SERVER,
  database: process.env.DB_NAME,
  options: {
    encrypt: true,
    trustServerCertificate: true,
  },
};

// Rate limiters
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 20,
  message: {
    success: false,
    error: 'Too many login attempts. Please try again later.'
  }
});

const bruteForceLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: {
    success: false,
    error: 'Too many brute force attempts. Please try again later.'
  }
});

// Middleware
app.use(cors());
app.use(express.json());
app.use(helmet());
app.use(morgan('combined'));

// Test database connection
async function testConnection() {
  try {
    const pool = await sql.connect(dbConfig);
    logger.info('Connected to MSSQL database');
    return pool;
  } catch (err) {
    logger.error(`Database connection failed: ${err}`);
    throw err;
  }
}

// Utility functions
function calculatePasswordStrength(password) {
  if (!password) return 'Weak';
  
  const hasUpper = /[A-Z]/.test(password);
  const hasLower = /[a-z]/.test(password);
  const hasNumber = /\d/.test(password);
  const hasSpecial = /[^A-Za-z0-9]/.test(password);
  const length = password.length;

  let strength = 0;
  if (length >= 12) strength += 2;
  else if (length >= 8) strength += 1;
  
  if (hasUpper) strength += 1;
  if (hasLower) strength += 1;
  if (hasNumber) strength += 1;
  if (hasSpecial) strength += 2;

  if (strength >= 6) return 'Strong';
  if (strength >= 4) return 'Moderate';
  return 'Weak';
}

// Routes
app.post('/sqlinjection/test', async (req, res) => {
  const { target, username, password } = req.body;

  if (!target || !username || !password) {
    return res.status(400).json({ success: false, error: 'Missing required fields' });
  }

  try {
    const config = {
      user: username,
      password: password,
      server: target,
      options: {
        encrypt: true,
        trustServerCertificate: true,
        connectionTimeout: 3000,
        requestTimeout: 5000
      }
    };

    const injectionTests = [
      {
        name: "Authentication Bypass",
        payloads: [
          `admin'--`,
          `' OR 1=1--`,
          `admin'/*`,
          `' OR 'a'='a`
        ],
        type: "classic",
        detection: (result) => ({
          vulnerable: result.recordset?.length > 0,
          evidence: result.recordset?.length > 0 ? 
            `Returned ${result.recordset.length} records` : ""
        })
      },
      {
        name: "Union Data Extraction",
        payloads: [
          `' UNION SELECT null,username,password FROM users--`,
          `' UNION ALL SELECT 1,table_name,column_name FROM information_schema.columns--`,
          `' UNION SELECT 1,@@version,db_name()--`
        ],
        type: "union",
        detection: (result) => {
          const extractedData = result.recordset?.find(r => 
            r.hasOwnProperty('password') || 
            r.hasOwnProperty('column_name') ||
            r.hasOwnProperty('username')
          );
          return {
            vulnerable: !!extractedData,
            evidence: extractedData ? 
              `Extracted: ${JSON.stringify(extractedData)}` : ""
          };
        }
      },
      {
        name: "Time-Based Blind",
        payloads: [
          `'; IF (SELECT COUNT(*) FROM users) > 0 WAITFOR DELAY '0:0:3'--`,
          `' AND (SELECT COUNT(*) FROM sysobjects) > 0 WAITFOR DELAY '0:0:3'--`,
          `'; IF SYSTEM_USER='sa' WAITFOR DELAY '0:0:3'--`
        ],
        type: "blind",
        detection: (result, responseTime) => ({
          vulnerable: responseTime > 2800,
          evidence: responseTime > 2800 ? 
            `Delayed response (${responseTime}ms)` : ""
        })
      }
    ];

    const results = [];
    let connection;

    try {
      connection = await sql.connect(config);

      for (const test of injectionTests) {
        let testResult = {
          test: test.name,
          type: test.type,
          vulnerable: false,
          evidence: "",
          payloads: []
        };

        for (const payload of test.payloads) {
          const startTime = Date.now();
          try {
            const request = connection.request();
            let query;
            
            if (test.type === "blind") {
              query = `SELECT TOP 1 * FROM sys.objects; ${payload}`;
            } else {
              query = `SELECT TOP 5 * FROM users WHERE username = '${payload}'`;
            }

            const result = await request.query(query);
            const responseTime = Date.now() - startTime;
            
            const { vulnerable, evidence } = test.detection(result, responseTime);
            
            testResult.payloads.push({
              payload,
              responseTime,
              success: true
            });

            if (vulnerable) {
              testResult.vulnerable = true;
              testResult.evidence = evidence;
              break;
            }

          } catch (err) {
            testResult.payloads.push({
              payload,
              responseTime: Date.now() - startTime,
              success: false,
              error: err.message.split('\n')[0]
            });

            if (test.type !== "blind") {
              const vulnerable = err.message.includes('UNION') || 
                               err.message.includes('conversion');
              if (vulnerable) {
                testResult.vulnerable = true;
                testResult.evidence = `Error reveals vulnerability: ${err.message.split('\n')[0]}`;
                break;
              }
            }
          }
        }

        results.push(testResult);
      }

      const vulnerabilitiesFound = results.filter(r => r.vulnerable);
      const severity = vulnerabilitiesFound.some(r => r.type === "union") ? "Critical" :
                      vulnerabilitiesFound.length > 0 ? "High" : "None";

      res.json({
        success: true,
        verdict: vulnerabilitiesFound.length > 0 ?
          `Found ${vulnerabilitiesFound.length} vulnerability types (Severity: ${severity})` :
          "No SQL injection vulnerabilities detected",
        severity,
        results,
        recommendations: vulnerabilitiesFound.length > 0 ? [
          "1. Implement parameterized queries/prepared statements",
          "2. Apply principle of least privilege to database accounts",
          "3. Configure web application firewall rules",
          "4. Validate and sanitize all user inputs"
        ] : ["Current SQL injection protections appear effective"]
      });

    } finally {
      if (connection) await connection.close();
    }
  } catch (err) {
    logger.error(`SQL Injection Test Error: ${err.message}`);
    res.status(500).json({
      success: false,
      error: "Test execution failed",
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
});

app.post('/bruteforce/test', bruteForceLimiter, async (req, res) => {
  const { target, username, wordlist } = req.body;

  if (!target || !username || !wordlist || !Array.isArray(wordlist)) {
    return res.status(400).json({ 
      success: false, 
      error: 'Invalid input parameters' 
    });
  }

  if (wordlist.length > 20) {
    return res.status(400).json({
      success: false,
      error: 'Wordlist too large (max 20 entries)'
    });
  }

  try {
    const results = [];
    let connection;
    let successPayload = null;

    try {
      const testConfig = {
        user: username,
        password: '',
        server: target,
        options: {
          encrypt: true,
          trustServerCertificate: true,
          connectTimeout: 3000
        }
      };

      connection = await sql.connect(testConfig);
      await connection.close();
      return res.json({
        success: false,
        error: 'Empty password accepted - extremely insecure configuration'
      });
    } catch (initialError) {
      // Expected error - proceed with testing
    }

    for (const password of wordlist.slice(0, 20)) {
      try {
        const config = {
          user: username,
          password: password,
          server: target,
          options: {
            encrypt: true,
            trustServerCertificate: true,
            connectTimeout: 3000
          }
        };

        connection = await sql.connect(config);
        await connection.request().query('SELECT 1');
        await connection.close();

        successPayload = password;
        break;
      } catch (err) {
        results.push({
          attempt: results.length + 1,
          success: false,
          error: 'Invalid credentials'
        });
      }
    }

    if (successPayload) {
      res.json({ 
        success: true, 
        results: [{
          result: 'Successful authentication',
          attempts: results.length + 1,
          passwordStrength: calculatePasswordStrength(successPayload),
          recommendation: 'Immediately change this password'
        }]
      });
    } else {
      res.json({ 
        success: false,
        results: results,
        message: `No valid credentials found after ${results.length} attempts`,
        recommendation: 'Ensure strong password policies are enforced'
      });
    }
  } catch (err) {
    logger.error(`Brute Force Test Error: ${err.message}`);
    res.status(500).json({ 
      success: false, 
      error: 'Test failed',
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
});

app.post('/enumerate', async (req, res) => {
  const { target, username, password } = req.body;

  if (!target || !username || !password) {
    return res.status(400).json({ 
      success: false, 
      error: 'All fields are required' 
    });
  }

  try {
    const config = {
      user: username,
      password: password,
      server: target,
      options: {
        encrypt: true,
        trustServerCertificate: true,
        connectionTimeout: 5000
      }
    };

    const pool = await sql.connect(config);
    
    const serverPermissions = await pool.request().query(`
      SELECT
        pr.name AS principal_name,
        pr.type_desc AS principal_type,
        pe.permission_name,
        pe.state_desc
      FROM sys.server_permissions pe
      JOIN sys.server_principals pr ON pe.grantee_principal_id = pr.principal_id
      WHERE pr.is_disabled = 0
      ORDER BY pr.name, pe.permission_name
    `);
    
    const dbPermissions = await pool.request().query(`
      SELECT
        pr.name AS principal_name,
        pr.type_desc AS principal_type,
        pe.permission_name,
        pe.state_desc
      FROM sys.database_permissions pe
      JOIN sys.database_principals pr ON pe.grantee_principal_id = pr.principal_id
      WHERE pr.is_fixed_role = 0
      ORDER BY pr.name, pe.permission_name
    `);
    
    const currentUser = await pool.request().query(`
      SELECT SYSTEM_USER AS login_name, USER_NAME() AS user_name
    `);
    
    await pool.close();
    
    const analyzePermissions = (permissions) => {
      const criticalPermissions = ['CONTROL SERVER', 'ALTER ANY LOGIN', 'ALTER ANY DATABASE', 'IMPERSONATE'];
      const highRiskPermissions = ['CREATE TABLE', 'ALTER', 'DELETE', 'EXECUTE'];
      
      return {
        totalPermissions: permissions.length,
        critical: permissions.filter(p => criticalPermissions.includes(p.permission_name)).length,
        highRisk: permissions.filter(p => highRiskPermissions.includes(p.permission_name)).length,
        principals: [...new Set(permissions.map(p => p.principal_name))].length
      };
    };

    const serverAnalysis = analyzePermissions(serverPermissions.recordset);
    const dbAnalysis = analyzePermissions(dbPermissions.recordset);

    res.json({
      success: true,
      currentUser: currentUser.recordset[0],
      serverPermissions: {
        count: serverAnalysis.totalPermissions,
        critical: serverAnalysis.critical,
        highRisk: serverAnalysis.highRisk,
        principals: serverAnalysis.principals
      },
      databasePermissions: {
        count: dbAnalysis.totalPermissions,
        critical: dbAnalysis.critical,
        highRisk: dbAnalysis.highRisk,
        principals: dbAnalysis.principals
      },
      securityAssessment: {
        overallRisk: serverAnalysis.critical > 0 ? 'Critical' : 
                   serverAnalysis.highRisk > 0 ? 'High' :
                   dbAnalysis.critical > 0 ? 'High' :
                   dbAnalysis.highRisk > 0 ? 'Medium' : 'Low',
        recommendations: [
          serverAnalysis.critical > 0 ? 'Review critical server-level permissions immediately' : null,
          dbAnalysis.critical > 0 ? 'Review critical database permissions' : null,
          'Apply principle of least privilege',
          'Regularly audit permissions'
        ].filter(r => r !== null)
      }
    });
  } catch (err) {
    logger.error(`Permission Enumeration Error: ${err.message}`);
    res.status(500).json({ 
      success: false, 
      error: 'Access denied or connection failed',
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
});

app.post('/api/reports/generate', async (req, res) => {
  const { scanResults, scanType, target } = req.body;
  
  if (!scanResults || !scanType || !target) {
    return res.status(400).json({ 
      success: false, 
      error: 'Missing required fields' 
    });
  }

  const validScanTypes = ['SQL Injection', 'Brute Force', 'Permissions'];
  if (!validScanTypes.includes(scanType)) {
    return res.status(400).json({
      success: false,
      error: 'Invalid scan type'
    });
  }

  try {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `report-${scanType}-${timestamp}.pdf`;
    const filepath = path.join(reportDir, filename);
    
    const generateSummary = (results, type) => {
      switch(type) {
        case 'SQL Injection':
          const vulns = results.filter(r => r.vulnerable);
          return {
            vulnerabilities: vulns.length,
            types: [...new Set(vulns.map(v => v.type))],
            severity: vulns.some(v => v.type === 'union') ? 'Critical' :
                     vulns.length > 0 ? 'High' : 'None'
          };
        case 'Brute Force':
          const success = results.some(r => r.success);
          return {
            attempts: results.length,
            compromised: success,
            strength: success ? 'Weak' : 'Strong',
            recommendation: success ? 'Change password immediately' : 'Current password policy appears effective'
          };
        case 'Permissions':
          return {
            criticalPermissions: results.serverPermissions.critical + results.databasePermissions.critical,
            highRiskPermissions: results.serverPermissions.highRisk + results.databasePermissions.highRisk,
            principals: results.serverPermissions.principals + results.databasePermissions.principals
          };
        default:
          return {};
      }
    };

    const generateStatistics = (results, type) => {
      if (type === 'SQL Injection') {
        return {
          payloadsTested: results.reduce((sum, test) => sum + test.payloads.length, 0),
          successfulPayloads: results.reduce((sum, test) => 
            sum + test.payloads.filter(p => p.success).length, 0),
          averageResponseTime: Math.round(
            results.reduce((sum, test) => 
              sum + test.payloads.reduce((s, p) => s + (p.responseTime || 0), 0) /
            results.reduce((sum, test) => sum + test.payloads.length, 0)
          )
      )};
      }
      if (type === 'Brute Force') {
        return {
          attempts: results.length,
          successRate: results.filter(r => r.success).length / results.length * 100
        };
      }
      return {};
    };

    const reportContent = {
      metadata: {
        scanType,
        target,
        generatedAt: new Date().toISOString(),
        reportVersion: '1.0'
      },
      summary: generateSummary(scanResults, scanType),
      details: scanResults,
      statistics: generateStatistics(scanResults, scanType)
    };

    fs.writeFileSync(filepath, JSON.stringify(reportContent, null, 2));
    
    res.json({
      success: true,
      filename,
      downloadUrl: `/api/reports/download/${filename}`,
      reportSummary: reportContent.summary
    });
  } catch (err) {
    logger.error(`Report Generation Error: ${err.message}`);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to generate report',
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
});

app.get('/api/reports/download/:filename', (req, res) => {
  const { filename } = req.params;
  const filepath = path.join(reportDir, filename);
  
  if (!fs.existsSync(filepath)) {
    return res.status(404).json({ 
      success: false, 
      error: 'Report not found' 
    });
  }

  res.download(filepath, `security-report-${filename}`, (err) => {
    if (err) {
      logger.error(`Report Download Error: ${err.message}`);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to download report'
      });
    }
  });
});

// Authentication Routes
app.post('/api/auth/login', authLimiter, async (req, res) => {
  const { username, password } = req.body;

if (!username || !password) {
  return res.status(400).json({ success: false, error: 'Username and password are required' });
}

try {
  const pool = await sql.connect(dbConfig);
  const result = await pool.request()
    .input('username', sql.NVarChar, username)
    .query('SELECT id, username, password_hash FROM Users WHERE username = @username');

  const user = result.recordset[0];
  
  if (!user) {
    return res.status(401).json({ success: false, error: 'Invalid credentials' });
  }

  // Compare the plaintext password directly with 'password_hash'
  if (password !== user.password_hash) {
    return res.status(401).json({ success: false, error: 'Invalid credentials' });
  }

  const token = jwt.sign(
    { id: user.id, username: user.username },
    process.env.JWT_SECRET || 'fallback_secret_should_be_in_env',
    { expiresIn: '1h' }
  );

  res.json({ success: true, token });
} catch (err) {
  logger.error(`Login Error: ${err.message}`);
  res.status(500).json({ success: false, error: 'Login failed' });
}

});

app.post('/api/auth/register', async (req, res) => {
  const { username, password } = req.body;
  
  if (!username || !password) {
    return res.status(400).json({ success: false, error: 'Username and password are required' });
  }

  try {
    const pool = await sql.connect(dbConfig);
    const userCheck = await pool.request()
      .input('username', sql.NVarChar, username)
      .query('SELECT * FROM Users WHERE username = @username');

    if (userCheck.recordset.length > 0) {
      return res.status(400).json({ success: false, error: 'Username already exists' });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    
    await pool.request()
      .input('username', sql.NVarChar, username)
      .input('password_hash', sql.NVarChar, hashedPassword)
      .query('INSERT INTO Users (username, password_hash) VALUES (@username, @password_hash)');

    res.status(201).json({ success: true, message: 'User registered successfully' });
  } catch (err) {
    logger.error(`Registration Error: ${err.message}`);
    res.status(500).json({ success: false, error: 'Registration failed' });
  }
});

// Error handling
app.use((err, req, res, next) => {
  logger.error(`${err.status || 500} - ${err.message}`);
  res.status(500).json({
    success: false,
    error: 'Internal Server Error',
    message: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});
const PDFDocument = require('pdfkit'); // You need to install it: npm install pdfkit

app.post('/api/reports/generate', async (req, res) => {
  const { scanResults, scanType, target } = req.body;
  
  if (!scanResults || !scanType || !target) {
    return res.status(400).json({ 
      success: false, 
      error: 'Missing required fields' 
    });
  }

  const validScanTypes = ['SQL Injection', 'Brute Force', 'Permissions'];
  if (!validScanTypes.includes(scanType)) {
    return res.status(400).json({
      success: false,
      error: 'Invalid scan type'
    });
  }

  try {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `report-${scanType}-${timestamp}.pdf`;
    const filepath = path.join(reportDir, filename);

    const generateSummary = (results, type) => {
      switch(type) {
        case 'SQL Injection':
          const vulns = results.filter(r => r.vulnerable);
          return {
            vulnerabilities: vulns.length,
            types: [...new Set(vulns.map(v => v.type))],
            severity: vulns.some(v => v.type === 'union') ? 'Critical' :
                     vulns.length > 0 ? 'High' : 'None'
          };
        case 'Brute Force':
          const success = results.some(r => r.success);
          return {
            attempts: results.length,
            compromised: success,
            strength: success ? 'Weak' : 'Strong',
            recommendation: success ? 'Change password immediately' : 'Password policy appears effective'
          };
        case 'Permissions':
          return {
            criticalPermissions: results.serverPermissions.critical + results.databasePermissions.critical,
            highRiskPermissions: results.serverPermissions.highRisk + results.databasePermissions.highRisk,
            totalPrincipals: results.serverPermissions.principals + results.databasePermissions.principals,
            overallRisk: results.securityAssessment.overallRisk
          };
      }
    };

    const summary = generateSummary(scanResults, scanType);

    // Create PDF
    const doc = new PDFDocument();
    const writeStream = fs.createWriteStream(filepath);
    doc.pipe(writeStream);

    // PDF Content
    doc.fontSize(20).text(`Security Scan Report`, { align: 'center' });
    doc.moveDown();
    doc.fontSize(14).text(`Target: ${target}`);
    doc.text(`Scan Type: ${scanType}`);
    doc.text(`Generated At: ${new Date().toLocaleString()}`);
    doc.moveDown();

    doc.fontSize(16).text(`Summary`, { underline: true });
    doc.moveDown(0.5);

    for (const [key, value] of Object.entries(summary)) {
      doc.fontSize(12).text(`${key}: ${JSON.stringify(value)}`);
    }

    doc.end();

    // After file is written
    writeStream.on('finish', () => {
      res.json({
        success: true,
        message: 'Report generated successfully',
        reportPath: `/reports/${filename}`,
        reportFile: filename
      });
    });

    writeStream.on('error', (err) => {
      logger.error(`PDF Generation Error: ${err.message}`);
      res.status(500).json({
        success: false,
        error: 'Failed to generate report'
      });
    });

  } catch (err) {
    logger.error(`Report Generation Error: ${err.message}`);
    res.status(500).json({ 
      success: false, 
      error: 'Report generation failed',
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
});

// Start server
testConnection().then(() => {
  app.listen(PORT, () => {
    logger.info(`Server running on port ${PORT}`);
    console.log(`Server running on port ${PORT}`);
  });
}).catch(err => {
  logger.error('Failed to start server');
  console.error('Failed to start server');
  process.exit(1);
});
